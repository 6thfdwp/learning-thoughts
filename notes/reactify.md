## Redux

• [Redux contract & constraint](https://www.youtube.com/watch?v=uvAXVMwHJXU&app=desktop)

> Most of things we write in redux is not using its api directly, but follow its contract, write pure functions, pass around and process plain objects etc

For example, we can use reducer inside component without Redux:

```js
this.setState((prevState) => reduce(prevState, action));
```

### Redux `createStore`

```js
const createStore = (reducer) => {
  let state; // the whole state tree
  let listeners = [];

  const getState = () => state;
  const dispatch = (action) => {
    state = reducer(state, action);
    listeners.forEach((l) => l());
  };

  const subscribe = (listener) => {
    listeners.push(listener);
    // unsubscribe hook
    // const unsubscribe = store.subscribe(handler)
    // later: unsubscribe()
    return () => {
      listeners = listeners.filter((l) => l !== listener);
    };
  };
  // populate the initial state
  dispatch({});

  return { getState, dispatch, subscribe };
};
```

**[State shape design](https://hackernoon.com/avoiding-accidental-complexity-when-structuring-your-app-state-6e6d22ad5e2a)**

Redux encourages you to think about your application in terms of the data you need to manage. Plain object as top of state tree, further divide data into subtree, each level's key represents some 'domain', state can have 3 categories

- Domain data (e.g from db model)
- App / UI state, the selected item, isPending, modalShown etc.

[Scalable state maintaining](https://techblog.appnexus.com/five-tips-for-working-with-redux-in-large-applications-89452af4fdcb)

• Use map for list of data and selector to access data  
• Separate data state (from db) from view State  
•

### Reducer composition

For every action, all sub reducers will be called passed in partial state each reducer handles and only react to action it is interested in (so every reducer has 'default' for non-interest action, just return the original state). The result will be merged back

```js
/***
state shape: {
  todos: [...],
  filter: 'string'
}
***/
const rootReducer = (state = {}, action) => {
  // nextState always a new object
  return {
    todos: todosReducer(state.todos, action),
    filter: filterReducer(state.filter, action),
  };
};
```

It's so common in practice, redux has `combineReducers` for this, an util to return `rootReducer` function. Can be used in all level of state, i.e nested combineReducers

```js
const combineReducers = (reducers) => {
  // this is passed to createStore, accept the whole current state tree
  return (state= {}, action) => {
    return Object.keys(reducers)
      .reduce((nextState, key) => {
         // call each reducer to produce the whole updated state tree
         nextState[key] = reducers[key](state[key], action)
         return nextState;
      }, {}) // a new initial nextState
  }
}
// use it to create createStore
createStore(combineReducers({
  todos: todosReducer // or todos if we export function name same as the state key
  filter
}))

combineReducers({
  todos: combineReducers({
    myTodo: (todos.myTodo, action) => next myTodo
    yourTodo: (todos.myTodo, action) => next yourTodo
  }),
  filter: otherReducer
})
```

### `connect` HOC to store

Container subscribes to store by providing handler fn, get state they need from store, setState on component. we use connect from `react-redux`. It is high order component wrapping around original container, and implement a performant `shouldComponentUpdate()` optimization which skips rendering if the part of the state selected by `mapStateToProps()` has not changed. When something changed, container receive nextState as props from high order component generated by `connect`. Instead of subscribing to store and `setState` explicitly inside container

```js
this.setState({
  data1: store.getState().data1,
});
// we do connect, no need to talk to store directly
connect(
  /**
   * mapStateToProps = (state, {params}) => ({
   *   todos: selector(state.todos, )
   * })
   **/
  mapStateToProps,
  /**
   * with following, we can this.props.onTodoClick which dispatch action created by `toggleTodo`
   * it's shorthand of mapDispatchToProps = (dispatch) => ({
   *   onTodoClick(id) {dispatch(toggleTodo(id))}
   * })
   **/
  { onTodoClick: toggleTodo, receiveTodos }
)(Component);
```

It's design concern to Find who need to act as container component which handles behaviour (e.g what happens when clicking), and delegate actual look to a set of presentational components, those handlers will passed down to presentation from container, where handlers are actually triggered

Instead of monkey patching, we could pass the 'enhanced' dispatch through middlewares chain, leaving `store.dispatch` not affected

```js
function logger(store) {
  // next is 'enhanced' dispatch fn returned from previous middleware
  return (next) => (action) => {
     console.log('dispatching ' + action );
     let result = next(action)
     console.log('next state', store.getState())
     return result
  }
}
// even shorter
const logger = store => next => action => {
  // next is 'enhanced' dispatch fn from previous middleware
}

const promise = store => next => action => {
  if (typeof action.then === 'function') {
    // next will receive response to dispatch action object
    return action.then(next);
  }
  return next(action);
}

function apply(store, middlewares) {
  ...
  // have a new ref to dispatch fn, we just updating a local variable
  // when applying each middleware
  let dispatch = store.dispatch
  middlewares.forEach(middleware => {
    dispatch = middleware(store)(dispatch)
  })

  return Object.assign({}, store, { dispatch })
}
apply(store, [promise, logger])
```

> When the last middleware in the chain dispatches an action, it has to be a plain object. This is when the synchronous Redux data flow takes place.

## Advanced topics

Some useful links for [state](https://stackoverflow.com/questions/48563650/does-react-keep-the-order-for-state-updates/48610973#48610973) discussion and [async setState](https://github.com/facebook/react/issues/11527#issuecomment-360199710)

- The state is updated in the same order as setState called. The most recent value of the same state key 'wins'

- The state update is batched  
  When called in event handler (click button), only single re-render at the end of event (but not batched when setting async data )

- The state is shallowly merged

```js
setState(pendingState: object || func, callback)
// when next state is based on previous state value
setState((prevState, props) => ({counter: prevState.counter + props.step}))
```

### HOC with Forwarded Ref

Introduced in 16.3, `Forwarded Ref` allow expose child DOM (or component instance) ref to parent component, by `forwarding` this ref variable via `React.createRef()` to the child component we want.  
How is this related to HOC pattern? Let's review what HOC is first. The definition is that HOC takes a component, return a new component. We use this newly decorated component outside, it has same look and feel as the original component inside.

Why need this? Main reason is to reuse logic (not UI like other functional components). Separate the logic from the presentation. See example below:

```js
function switcher(WrappedComponent) {
  class Switcher extends Component {
    constructor(props) {
      super(props);
      this.state = {
        toggled: false,
      };
    }
    toggle() {
      this.setState((prevState, props) => ({ toggled: !prevState.toggled }));
    }
    render() {
      // the wrapped can trigger onToggle and re-render
      // based on toggled state passed into
      <WrappedComponent
        {...this.props}
        toggled={this.state.toggled}
        onToggle={this.toggle}
      />;
    }
  }
  return Switcher;
}

switcher(<PlayButton />);
switcher(<LoopButton />);
```

All things can be made switchable. They don't have to be button at all! Anything clickable and have flipped state to show ui accordingly, can be enhanced.

Redux `connect` is similar pattern, make `store.subscribe`, receive new state and `shouldComponentUpdate` reusable, can be opted into any container component that need to be aware of state change.

Let's look at the `forwardRef` now.

```js
// ref can only be passed with forwardRef in additional to normal props
const FancyButton = React.forwardRef((props, ref) => (
  <button ref={ref} className='FancyButton'>
    {props.children}
  </button>
));
// since FancyButton is forwarding ref, the ref will not point to its own instance
// FancyButton now have access to underlying button instance via ref.current
const ref = React.createRef();
<FancyButton ref={ref}>Click</FancyButton>;
```

Here is another use case for HOC, implemented as `render` callback, allow extra prop `ref` to be passed to child down the tree. Without it, the ref will not be passed.
`withRouter` has similar way to pass extra route related props (location etc)

### Effect Hooks

`useEffect` is used to 'schedule' some callbacks to perform side effect, like API calls, set up subscription / timeout / event handler and manual DOM manipulation. We can think of applying effect as synchronisation between each React rendering. After each rendering or dependencies the effect relies on change, the effect function is able to synced with latest state and props. It might server similar purpose to `didMount`, `didUpdate` lifecycles, but very different in terms of underlying execution.

- The time it gets triggered  
  React remembers each effect function for each render, execute them in order after committing changes to DOM and browser painting the screen. So it does not block browser from updating the screen.

  > Although useEffect is deferred until after the browser has painted, it’s guaranteed to fire before any new (next) renders. React will always flush a previous render’s effects before starting a new update.

- Part of rendering result  
  Each rendering creates a new effect function that captures `props` and `state` belong to that particular render (through JS closure) if it does not specify any in the dependency array. If empty array, effect always referencing the props and state variables from first render.

- Clean up  
  Same rule as running effect, the 'clean up' function from previous effect is triggered after React current rendering and Browser painting, and then apply new effect belongs to the current rendering.

  ```js
  function FriendStatus(props) {
    useEffect(() => {
      // ...
      ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
      return () => {
        ChatAPI.unsubscribeFromFriendStatus(
          props.friend.id,
          handleStatusChange
        );
      };
    }, [props.friend.id]);
  }
  ```

  When friend id changed from 10 -> 20,

  - React renders UI with new props {id: 20}
  - React commits updates and Browser paints
  - Clean up effect: unsubscribe(10)
  - Effect applied subscribe(20)

  //

- Avoid effect re-run  
  All props, state variables and inner functions in the component used by effect becomes effect's dependencies. It requires us to think clearly what triggers the effect running, specify them clearly in the dependancy array.

  If we want to only run effect and clean up once, blindly specify empty array to trick React could end up with some bugs.

  ```js
  function Counter() {
    const [count, setCount] = useState(0);

    useEffect(() => {
      // interval callback always runs setCount(0 + 1)
      // as it captures initial state count = 0
      const id = setInterval(() => setCount(count + 1), 1000);
      return () => clearInterval(id);
    }, []);

    return <span>{count}</span>;
  }
  ```

  One way to do is to useReducer to separate how state gets updated from effect. So effect does not rely on any state, it only triggers the intention to update through `dispatch`.

  ```js
  function Counter(props) {
    const [state, dispatch] = useReducer(reducer, { count: 0, step: 1 });
    const reducer = (state, action) => {
      const { count, step } = state;
      switch (action.type) {
        case 'tick':
          return { count: count + step, step };
        default:
          return state;
      }
    };

    useEffect(() => {
      const id = setInterval(() => dispatch({ type: 'tick' }), 1000);
      return () => clearInterval(id);
      // can omit dispatch, as it is not created between render,
      // useReducer always returns the same dispatch function
    }, [dispatch]);
  }
  ```

### Performance

`shouldComponentUpdate`: "Should component related UI need to be updated?"  
If yes, we certainly need to perform reconciliation process: re-rendering on that component to generate new elements tree, diff it with previous and figure out DOM updates.  
If no, we can skip the process from that component and its entire subtree.

Most case, it does not hurt when always re-rendering the whole subtree upon a component state change.

• Functional (stateless) component  
Implemented as pure function (not Pure component), the output is only based on input props

• PureComponent  
Class component, stateless or stateful, could perform side effect, but only re-render when props or state changed

• Normal Component

> It is safe to use PureComponents as atoms, ie small and final things like buttons. But it is not safe to use them in chromes, forms, pages and other molecules.

https://building.calibreapp.com/debugging-react-performance-with-react-16-and-chrome-devtools-c90698a522ad

---

## Generalize the Middleware

We've seen this pattern a lot, in Express, Redux and Apollo client. Generally it is used to provide great extensibility to the core framework, each middleware is like a plugin function that's attached to the processing pipeline, and gets invoked in order.  
Each middleware function implement what to do (custom portion of logic), receives a special `next` funciton (implemented by the framework) [x1] to pass the execution to the next middleware, until it reaches to the last or the early return (e.g error thrown).

### The components of a middleware library

- Provide interface to apply (attach) middlewares
  Express `.use`, redux `applyMiddleware`

- A way to execute pipeline and magic `next`
  Express implements a handle to pass in NodeJS http.createServer, gets triggered when receving requests. It iterates a stack of layers (which is a simple object wrapper of middleware fn) to trigger. There could be extra logic if it's a router middleware, where it also tries to match the request url path.

  In Redux, it is through `dispatch` call where each middleware is essentially an enhanced function based on original dispatch

### Express middleware

### Redux middleware

> Middleware provides some extension point between dispatching an action and the moment it reaches the reducer. It enhances 'dispatch' which is only for plain action object, allow you dispatch anything as long as there is middleware handles it

```js
// suppose this is the first middleware to be applied
function logger(store) {
  const chainedDispatch = store.dispatch;
  // this new fn will be assigned to original dispatch, it accept same parameters: 'action' object
  // but with extra logic added into original dispatch
  return (action) => {
    console.log('dispatching ' + action);
    let result = chainedDispatch(action);
    console.log('next state', store.getState());
    return result;
  };
}
function reporter(store) {
  // this is 'enhanced' dispatch from previous applied logger middleware
  const chainedDispatch = store.dispatch;
  return (action) => {
    // do other more stuff

    // chainedDispatch will do logging at this point
    chainedDispatch(action);
  };
}
// let's have a util to apply all middlewares, a way to compose (chain) middlewares
function applyByMonkeyPatching(store, middlewares) {
  // do not affect middlewares array passed in
  middlewares = middlewares.slice();
  middlewares.reverse();

  middlewares.forEach((middleware) => {
    // every time a middleware gets applied, 'dispatch' is monkeypatched
    // the next middleware in the chain will be based on this patched one
    store.dispatch = middleware(store);
  });
}
```

▪︎ [x1] a bit like IoC? As Wiki explains: Cusom portions of a computer program receive the flow of control from a generic framework

---

## Patterns implement IoC

> Don't call us, I will call you

### IoC through Dependency Injection (DI)

What is acutally inverted ?  
The dependency is never acquired through client(consumer) class itself by direct instantiation (aka `new`), but injected from outside mostly passed as abstract interface.

### IoC through Observer

Similar in event listener, what is inverted is the control of when observer gets called and passed in necessary info they are interested in, not observer goes to grab and do stuff.  
The observable subject is the one who controls when it triggers and what info it passes

### IoC through Template method

What is acutally inverted ?  
The subclass implements methods, but get called by super class.
Like old Java Servlet world or React class component(deprecated..), our components implement lifecycle methods, it's React to decide when to trigger them.
