This learning starts from inspiring series of blog posts [Didact: DIY your own React](https://engineering.hexacta.com/didact-learning-how-react-works-by-building-it-from-scratch-51007984e5c5)

React.Element is light weight object representation of actual UI (DOM in web, View hierarchy in native).  
Component is definition to return the Element.  
```js
StoryLike = ({likes, url, name}) => (
  <li className='row'>
    <button onClick={handler}>{likes}❤️</button>
    <a href={url}>{name}</a>
  </li>
)
```
We use JSX `<StoryLike />` to easily compose the hierarchy, which essentially get transpiled via Babel to `React.createElement`, it will recursively check component hierarchy to make nested `createElement` call for each node
```js
createElement(
  'li', {className:'row'},
  // no props, the second argument will be null
  createElement('button', {onClick: handler}, likes, '\u2764\uFE0F'),
  createElement('a', {href: url}, name)
)
```
The final returned element object tree from StoryLike looks like this:
```js
{                    
  type:'li',
  props:{
    className:'row',
    children: [
      {
        type:'button',
        props:{   
          onClick: handler,
          children:[
            {type:'TEXT_ELEMENT', props:{nodeValue: ${likes}, children:[]}}
            {type:'TEXT_ELEMENT', props:{nodeValue: 'likes', children:[]}}
          ]
      }},
      {
        type:'a',
        props:{
          href:${url}, children:[type:'TEXT_ELEMENT',...]
        }}
    ]}
}

```
ReactDOM and ReactNative both use the same React base, React responsible for generating virtual UI representation upon state change, diff and figure out minimum update.   
ReactDOM turns it to imperative, mutative calls to DOM API (appendChild, createTextNode..), ReactNative turns it into a single JSON message that lists mutations [['createView', attrs], ['manageChildren',] ...]

The core consists of 3 recursive calls, one generate element object tree, the other two walks it recursively to operate DOM

`createElement(type, props, ...rest)`:  
generate element object tree representing UI snapshot. rest contains children nodes in each type level, each will be passed to `createElement` again recursively form sub tree

`instantiate(element): {dom, element, childInstances}`:  
transform the element object tree to related DOM node hierarchy and link them together. Each type level will be instantiated as well as its children by recursive again, children DOM node will be appended. The final returned object is {dom, element, childInstances}, childInstances has similar form  {childDom, childElement, ...}. This is where DOM construction happens

`reconcile(parentDom, prevInstance, nextElement)`:   
The top level call starts from root container, root instance from previous render (null in first reconcile), the whole element object tree generated by next render. This is where DOM update happens

In the first reconcile, it will instantiate the whole DOM tree, and append it to root container.  

In the following reconcile, it tries to compare each type level of `prevInstance` 's element with `nextElement` from `createElement`  
• If type is the same,   
**Reuse** the DOM node in this level, replace its all props with those in nextElement (brutal), and recursively check its children (reconcileChildren).  

• If type is not the same  
Call `instantiate` against current level of nextElement, replace `prevInstance` DOM with newly created DOM

Only Compare children order during reconcileChildren, i.e take first from current level of instance's `childInstances` against the first current level of nextElement.props.children, and so on.  

• If both have the same length (only DOM node props updates needed)  
each child's props will be replaced with nextElement prop's value, like upon clicking like button, `button` text node needs to be increased by 1  
• If nextElement's children has more (new DOM node appended)  
For those not in the prevInstance.childInstances, reconcile will be called with `prevInstance` undefined  
• If instance.childInstances has more (DOM node removed)

**Component**   
Allow local state update and apply `reconcile` on affected subtree,
```js
setState(partial) {
  this.state = object.assign({}, this.state, partial)
  // trigger reconcile against component subtree
  // need to know where we start reconciling
}
```

In old React before Fibre, main reconciling algorithm is called [Stack Reconciler](https://reactjs.org/docs/implementation-notes.html)   
Reconciler mainly doing walk through element object tree, figure out each what to render in each level, hand over to renderer to do platform specific work

React Reconciler rely on internal instance hierarchy which gets created by mounting  original element object tree level by level, use this hierarchy to do updating (reuse node as possible)
```js
// App.js
render() {
  <div >
    <h1>{props.title}</h1>
    <StoryLike story={story} />
  </div>
}
```
when `render(<App title='' />)`, will walk through element object hierarchy to create internal instances end up like:

```
CompositeComponent App
 > currentElement: {type: App(function), props:{title, children:[]}}
 > publicInstance: new App()
 > renderedComponent: DOMComponent
   > currentElement: {type:"div", props:{children:[..]}}
   > node: div
   > renderedChildren: [
     DOMComponent: {
       > currentElement: {type:'h1'},
       > node: h1
       > renderedChildren: [DOMComponent]
     CompositeComponent:
       > currentElement: {type: StoryLike, props:{children:[]}}
       > publicInstance: new StoryLike()
       > renderedComponent: DOMComponent {
         > currentElement {type:'li', ..}
         > node: li
         > renderedChildren: [
           DOMComponent button,
           DOMComponent a
         ]
   ]
```

**Fiber incremental reconciliation**   
[Fiber architecture](https://github.com/acdlite/react-fiber-architecture)

> split rendering work into chunks and spread it out over multiple call stack frames.

### Advanced topics
---
**State**  
The main way (only?) to trigger UI update is by `setState`, and then pass further down via `props`:   
[State answer](https://stackoverflow.com/questions/48563650/does-react-keep-the-order-for-state-updates/48610973#48610973)  
[Async setState](https://github.com/facebook/react/issues/11527#issuecomment-360199710)

• The state is updated in the same order as setState called, the most recent value of the same state key 'wins'  
• The state update is batched when called in event handler (click button), only single re-render at the end of event (but not batched when setting async data )  
• The state is shallowly merged  

```js
setState(pendingState: object || func, callback)
// when next state is based on previous state value
setState((prevState, props) => ({counter: prevState.counter + props.step}))
```

**HOC with Forwarded Ref**   
Introduced in 16.3, `Forwarded Ref` allow expose child DOM (or component instance) ref to parent component, by `forwarding` this ref variable via `React.createRef()` to the child component we want.  
How is this related to HOC pattern? Let's review what HOC is first. The definition is that HOC takes a component, return a new component. We use this newly decorated component outside, it has same look and feel as the original component inside.   

Why need this? Main reason is to reuse logic (not UI like other functional components). Separate the logic from the presentation. See example below:
```js
function switcher(WrappedComponent) {
  class Switcher extends Component {
    constructor(props) {
      super(props);
      this.state = {
        toggled: false
      }
    }
    toggle() {
      this.setState((prevState, props) => ({toggled: !prevState.toggled}))
    }
    render() {
      // the wrapped can trigger onToggle and re-render
      // based on toggled state passed into
      <WrappedComponent
        {...this.props}
        toggled={this.state.toggled}
        onToggle={this.toggle} />
    }
  }
  return Switcher;
}

switcher(<PlayButton />)
switcher(<LoopButton />)
```
All things can be made switchable. They don't have to be button at all! Anything clickable and have flipped state to show ui accordingly, can be enhanced.

Redux `connect` is similar pattern, make `store.subscribe`, receive new state and `shouldComponentUpdate` reusable, can be opted into any container component that need to be aware of state change.

Let's look at the `forwardRef` now.
```js
// ref can only be passed with forwardRef in additional to normal props
const FancyButton = React.forwardRef((props, ref) => (
  <button ref={ref} className="FancyButton">
    {props.children}
  </button>
));
// since FancyButton is forwarding ref, the ref will not point to its own instance
// FancyButton now have access to underlying button instance via ref.current
const ref = React.createRef();
<FancyButton ref={ref}>Click</FancyButton>
```

Here is another use case for HOC, implemented as `render` callback, allow extra prop `ref` to be passed to child down the tree. Without it, the ref will not be passed.
`withRouter` has similar way to pass extra route related props (location etc)
